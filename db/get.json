#!/usr/bin/perl
######################################################################
# sources/get.json 
# 
# get webso sources
#
# inputs:
#   - source_url :              string 
#   - source_type:              string
#   - source_user:              string
#   - source_level_sharing :    int
#   - source_nb :               int
#   - source_start :            int
# Contributors:
#   - Arnaud Gaudinat : 11/08/2013
######################################################################

use strict;
use CGI;
use JSON;
use lib "..";
use LWP::UserAgent;
use Config::Simple;
use Digest::MD5 qw(md5 md5_hex md5_base64);
use URI::Encode qw(uri_encode uri_decode);


my $q       = CGI->new;
# prepare the JSON msg
my $json    = JSON->new->allow_nonref;

my $callback = q{};

my %perl_response = (    
    );



# reading the conf file
my $cfg     = new Config::Simple('../../webso.cfg');

if (Config::Simple->error()) {
    push @{$perl_response{'error'}},'Config file error';
    $perl_response{'debug_msg'} = Config::Simple->error();
}
else {
my $deb_mod = $cfg->param('debug');


my $SOURCE_URL              = $cfg->param('source_url');
my $SOURCE_TYPE             = $cfg->param('source_type'); 
my $SOURCE_USER             = $cfg->param('source_user');
my $SOURCE_LEVEL_SHARING    = $cfg->param('source_level_sharing');


my $query = q{};

my $source_url = q{};
if ($q->param('source_url')) {
    $source_url     = $q->param('source_url');
    $query .= '&fq=source_url_s:'.$source_url;
}

my $source_type = q{};
if ($q->param('source_type')) {
    $source_type    = $q->param('source_type');
    $query .= '&fq=source_type_s:'.$source_type;
}

my $source_user = q{};
if ($q->param('source_user')) {
    $source_user    = $q->param('source_user');
    $query .= '&fq=source_user_s:'.$source_user;
}
else {
	push @{$perl_response{'error'}},'source_user required';
}


my $source_level_sharing = 0;
if ($q->param('source_level_sharing')) {
    $source_level_sharing    = $q->param('source_level_sharing');
    $query .= '&fq=source_level_sharing_i:'.$source_level_sharing;
    
}



if ($q->param('callback')) {
    $callback    = $q->param('callback');    
}

if (!(exists $perl_response{'error'})) { 
my $id = md5_hex($source_user.$source_url);

my %query = (
    'id'                    => 's_'.$id,
    'type_s'                => 'source',
    
    $SOURCE_URL             => $source_url,
    $SOURCE_TYPE            => $source_type,
    $SOURCE_USER            => $source_user,
    $SOURCE_LEVEL_SHARING   => $source_level_sharing,
    
    );




my $json_text   = $json->pretty->encode(\%query);

# concatenate query and response
%perl_response = (%perl_response,%query);


# init user_agent
my $ua = LWP::UserAgent->new;
$ua->timeout(10);
$ua->env_proxy;

# accessing values:
#my $db_source = $cfg->param('db_source').'update -H \'Content-type:application/json\' -d ';



#my $response = $ua->request($req);

 

my  $query_encoded = uri_encode(
    'collection1/select?q=*:*'
    .$query
    .'&wt=json&indent=true');


my $response = $ua->get($cfg->param('db_source').$query_encoded);
 
if ($response->is_success) {
     $perl_response{success} = $json->decode( $response->decoded_content);  # or whatever
     
}
else {
    $perl_response{'error'} = 'sources server or service: '.$response->code;
    if ($deb_mod) {
        $perl_response{'debug_msg'} = $response->message;   
    }   
}
}

}

my $json_response   = $json->pretty->encode(\%perl_response);

if ($callback) { 
    print 'Access-Control-Allow-Origin: *';
    print 'Access-Control-Allow-Methods: GET'; 
    print "Content-type: application/javascript\n\n";
    $json_response   = $callback.'('.$json_response.');';
} else { 
    # Header for access via browser, curl, etc. 
    print "Content-type: application/json\n\n"; 
} 

print $json_response; 
 